/*
 * generated by Xtext 2.9.1
 */
package org.casualintellect.formatting2

import com.google.inject.Inject
import org.casualintellect.casualIntellect.Model
import org.casualintellect.casualIntellect.ProcessAfterState
import org.casualintellect.casualIntellect.ProcessBeforeState
import org.casualintellect.casualIntellect.ProcessInState
import org.casualintellect.casualIntellect.State
import org.casualintellect.casualIntellect.Transition
import org.casualintellect.casualIntellect.Transitions
import org.casualintellect.services.CasualIntellectGrammarAccess
import org.eclipse.emf.ecore.EObject
import org.eclipse.xtext.formatting2.AbstractFormatter2
import org.eclipse.xtext.formatting2.IFormattableDocument

import static org.casualintellect.casualIntellect.CasualIntellectPackage.Literals.*

class CasualIntellectFormatter extends AbstractFormatter2 {

	@Inject extension CasualIntellectGrammarAccess

	def dispatch void format(Model model, extension IFormattableDocument document) {
		model.prepend[setNewLines(0, 0, 1); noSpace].append[newLine]

		for (State list_of_states : model.getList_of_states()) {
			list_of_states.format;
		}
	}

	def dispatch void format(State state, extension IFormattableDocument document) {
		val open = state.regionFor.keyword('{');
		val close = state.regionFor.keyword('}');
		open.append[newLine]
		state.regionFor.feature(STATE__NAME).surround[oneSpace]
		interior(open, close)[indent]
		state.getBefore.format;
		state.getAfter.format;
		state.getInProcess.format;
		state.getTransitions.format;
		close.prepend[noSpace]
		close.prepend[newLine]
	}

	def dispatch void format(ProcessBeforeState beforeState, extension IFormattableDocument document) {
		processStateAction('before', beforeState, document);
	}

	def dispatch void format(ProcessAfterState afterState, extension IFormattableDocument document) {
		processStateAction('after', afterState, document);
	}

	def dispatch void format(ProcessInState inState, extension IFormattableDocument document) {
		processStateAction('after', inState, document);
	}

	def dispatch void format(Transitions transitions, extension IFormattableDocument document) {
		val left=transitions.regionFor.keyword('{');
		left.prepend[newLine]
		val right=transitions.regionFor.keyword('}');
		interior(left, right)[indent];
	
		right.prepend[newLine]
		val transitionsList = transitions.list;

		for (transition : transitionsList) {
			transition.format;
		}

	}

	def dispatch void format(Transition transition, extension IFormattableDocument document) {
		val transitionKeyword=transition.regionFor.keyword('transition');
		transitionKeyword.prepend[indent]
		transitionKeyword.prepend[newLine];
	}

	def void processStateAction(String keyword, EObject action, extension  IFormattableDocument document) {
		val before = action.regionFor.keyword('before');
		before.prepend[indent]
		val semicolon = action.regionFor().keyword(';');
		semicolon.append[newLine]
	}

// TODO: implement for Transitions, Transition, Or, And, NestedExpression, Not
}
