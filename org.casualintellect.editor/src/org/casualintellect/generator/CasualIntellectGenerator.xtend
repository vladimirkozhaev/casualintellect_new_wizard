/*
 * generated by Xtext 2.9.1
 */
package org.casualintellect.generator

import java.util.List
import org.casualintellect.casualIntellect.And
import org.casualintellect.casualIntellect.BoolConstant
import org.casualintellect.casualIntellect.Expression
import org.casualintellect.casualIntellect.Not
import org.casualintellect.casualIntellect.Or
import org.casualintellect.casualIntellect.State
import org.casualintellect.casualIntellect.StringConstant
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import org.casualintellect.casualIntellect.NestedExpression

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class CasualIntellectGenerator extends AbstractGenerator {

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		var states = "";
		for (e : resource.allContents.toIterable.filter(typeof(State))) {
			states = states + e.compile;
			states = states + "\n"
		}
		fsa.generateFile("states/states" + ".xml", states)
	}

	def compile(State state) {
		'''<state name="«state.name»">
	<before methods="«if(state.before != null) processMethodsList(state.before.methods)»"/>
	<after methods="«if(state.after != null) processMethodsList(state.after.methods)»"/>	
	<in_process methods="«if(state.inProcess != null) processMethodsList(state.inProcess.methods)»"/>
	<transitions>«IF (state.transitions != null)»
		«FOR transition : state.transitions.list»
			<transition name="«transition.name»" methods="«processMethodsList(transition.methods)»">
				<condition function="«transition.condition.compile»"/>
			</transition>
		«ENDFOR»
	«ENDIF»</transitions>
</state>
'''
	}

	def compile(Expression expression) {
		switch (expression) {
			Or: {

				compile(expression.left) + ' || ' + compile(expression.right);
			}
			And: {
				compile(expression.left) + ' && ' + compile(expression.right);
			}
			Not:
				expression.expression.compile
			NestedExpression:
				'(' + expression.child.compile + ')'
			BoolConstant:
				Boolean::parseBoolean(expression.value)
			StringConstant:
				expression.value
		}
	}

	def processMethodsList(List<String> methods) {
		var methodsStr = "";
		for (var i = 0; i < methods.length; i++) {
			methodsStr = methodsStr + methods.get(i);
			if (i < methods.length - 1) {
				methodsStr += ',';
			}
		}
		methodsStr;
	}
}
